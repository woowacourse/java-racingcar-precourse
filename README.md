## 🔥 My Feedback of Mission1

1. MVC 패턴구현
  1. MVC 패턴 설계단계에서 Controller에게 너무 많은 기능을 위임했다.
  2. 예를 들면 사용자의 정답을 입력받고 정답의 상태를 출력하는 과정은 Controller 가 아닌 View에게 위임 했었어야 했다.
  3. 특히 Model에서는 다른 컴포넌트들과는 전혀 상관 없이 개발을 했었어야 했는데, 그게 조금 부족했었던 것 같다.
2. Magic Number의 사용
  1. 최대한 많은 상수들을 constant 패키지에 묶어서 사용하려고 했었지만, 리팩토링 하는 과정에서 그냥 native하게 바로 숫자를 넣어버렸다.
  2. 좀 더 디테일 하게 모든 코드들을 확인하고 리팩토링 할 필요가 있다.
3. Readme.md의 활용
  1. 리드미의 활용이 부족했다.
  2. 물론 미션의 요구사항이 리드미에는 내가 구현할 앱의 기능 요구사항을 작성하라고 적혀 있긴 하지만, 리드미에는 기본적으로 이 앱의 abstraction, getting start, Interface definition등이 있어야 한다. 과제 제출이라는 특수한 상황이기 때문에 리드미가 일반적인 리드미와는 형식이 당연히 다르겠지만, 리드미의 기본적인 Content는 담으려고 노력하자.
  3. 리드미의 기능 목록을 업데이트 하라 라는 피드백을 받았다. 그렇다. 리드미는 계속 바뀔 수 있고 바뀔 필요가 있다. 물론 초기 설계를 와해시키면서 까지 개발을 진행하고 그거에 맞춰서 리드미를 바꾸는 개발은 지양해야 겠지만, 초기 설계에 갖혀서 개발 중간에 생각나는 아이디어들을 반영하지 말아야 한다는 법은 절대 없다!! 살아있는 문서를 만들기 위해 노력하자.
4. Git
  1. commit message를 의미있게 남기자.
  2. 현재는 pr을 단순히 upstream에 제출 용도로 사용하고 있지만 앞으로는 origin/hoho00를 main branch로 삼아서 pr하는 연습을 해야 겠다.
  3. 즉, 위의 말을 아래 브랜치로 한다면 현재 내 repo의 main branch는 사용하지 않고, origin/hoho00를 아래 그림의 master로 삼는다. 그리고 release branch 와 dev브랜치를 만들어서 release branch 에서는 bug fix만 일어 날 수 있도록 하고(원래는 QA들에 의해서 발생 하는 pr이다.) develop브랜치를 따로 만들고, feature브랜치들도 따로 만들 것이다. develop branch 는 테스팅 및 구현의 merge, release 브랜치로 갈 준비를 한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/758a08b7-5b76-4c8f-99ae-9ac8ee573f82/Untitled.png)

Mission1에서 MVC(Model-View-Controller) Pattern을 이용해서 구현했었다. Mission2에서도 동일하게 MVC Pattern을 적용하여 구현 하려고 한다.

그리고 pobi가 주신 피드백과 위의 자체 피드백을 수용하여 2주차를 완성시켜보자.

### Conclusion of Feedback

1. 역지사지
  1. "아무것도 모르는 타인이 내 코드를 봤을 때 한눈에 이해 할 수 있게 코딩" 해야 한다. 그것이 코딩컨벤션을 지키는 이유이고, 클래스와 매서드의 분리화를 하는 이유이고, 리드미와 깃 커밋메세지를 형식에 맞게 적는 이유이다.
  2. 하지만, 내가 코딩을 하고 그것을 다시 내가 검수하기란 쉬운 일은 아니다. 왜냐하면, 나의 좁은 시선으로 내 코드를 다시 봐 봤자 내가 짠 코드라서 객관적인 시선에서 비판하기 힘들기 때문이다. 그리고 나는 이 코드를 짠 사람으로서 코드에 대한 이해가 전반적으로 다 되어 있는 사람이기 때문에 코드리뷰에 주관적인 안일함이 섞일 수 밖에 없다.
  3. 그래서 내가 굳이 내 브랜치로 pr을 보내면서 까지 깃 워크플로우와 리드미를 중요시 하게 여기는 이유는 "남의 시선에서 내 코드를 보기" 위함이다. 내가 master branch의 주인이 되어서 다른 사람들의 pr들을 철저하게 방어하는 심정으로 코드를 보다 보면 좀 더 객관적인 시선에서 코드를 분석할 수 있다. 코딩도 좀 더 객관적인 시선으로 차갑게 할 수 있을 것 같다.

## 🔥Functional Requirements

### 🔥용어 정리

1. 프로그램의 전체 이름은 "자동차 경주 게임" 혹은 "게임" 이라고 정의 한다.
2. 자동차 경주 게임을 사용 하는 사람을 "사용자" 라고 정의 한다.
3. 사용자의 standard input을 받는 곳을 "콘솔창" 이라고 정의 한다.
4. 게임을 실행하는 주체를 "컴퓨터"이라고 정의 한다.

### 🔥Features (MVC Pattern)

1. View
  1. 사용자에게 콘솔창을 통해서 경주할 자통차의 이름을 입력 받는다.
  2. 사용자에게 콘솔창을 통해서 경주를 시도할 회수를 입력 받는다.
  3. 컴퓨터는 콘솔창을 통해서 각 차수별 실행결과를 요구사항의 형식에 맞춰서 출력한다.
  4. 컴퓨터는 콘솔창을 통해서 우승자의 안내를 형식에 맞춰서 출력한다.
    1. 형식은 단독우승자의 형식과 공동우승자의 형식이 있다.
    2. 우승자의 상태에 따라 다르게 출력한다.
    3. 주의 할 점은 우승이 단독우승인지 공동우승인지의 판단은 view가 하면 안된다. 컨트롤러에게 위임한다.
  5. 각 예외상황의 에러문구를 출력한다.
2. Controller
  1. n 대의 자동차를 생성 후 배열에 저장한다.
  2. 자동차의 배열의 각각의 자동차들에게 이름을 부여 한다.
  3. makeMove : Model에게 움직임을 준다.
3. Model : 절대 Controller 나 View의 객체를 참조하여서는 안된다!! Model은 Controller에 의해서 사용되어야만 하며, View는 인터페이스화 된 Controller를 사용할 뿐이다.
  1. GameData : 전체 게임에 사용되는 데이터의 저장 및 관리
    1. winCountOfCars : car들의 우승 횟수를 Map 형태로 저장 한다. key는 "car의 이름" value는 "우승 횟수"이다.
    2. finalWinners : 최종우승자들의 배열이다.
  2. GameDataOfOneCycle : 게임의 1사이클에 사용되는 데이터의 저장 및 관리
    1. cars : Car의 배열이다.
    2. isSoloWin : 단독우승인지 아닌지 상태이다.
    3. winners : 우승자의 배열이다.
  3. Car
    1. name
    2. position
4. Exceptions
  1. 사용자가 콘솔창에 입력한 이름이 5자 이상일 때
  2. 시도 횟수가 숫자가 아닌 다른 값일 때